/*
  Simple Web Worker (ES module worker) that loads the wasm-pack ESM glue and exposes a small
  compute interface. Worker protocol (messages):
    { cmd: 'init', baseUrl: '/wasm-proto/pkg' } -> replies { cmd: 'ready' } or { cmd: 'error' }
    { cmd: 'compute', data: ArrayBuffer|Float64Array } -> replies { cmd: 'result', result: ArrayBuffer }

  Notes:
  - This worker expects the wasm-pack `pkg` output to expose an ESM module at `wasm_proto.js`.
  - The worker is intended to be created with `new Worker('js/modules/wasm-worker.js', { type: 'module' })`.
*/

let wasmReady = false;
let wasmModule = null;

self.addEventListener('message', async (ev) => {
    const msg = ev.data;
    if (!msg || !msg.cmd) return;

    if (msg.cmd === 'init') {
        const base = msg.baseUrl || '/wasm-proto/pkg';
        try {
            try { self.postMessage({ cmd: 'loading', baseUrl: base, requestId: msg.requestId }); } catch (e) {}

            // Build candidate URLs for the ESM glue and wasm binary.
            // Normalize base to ensure it ends with '/' so relative URL resolution
            // points into the pkg folder (avoids replacing the last path segment).
            const normalizedBase = (typeof base === 'string' && base.length && base.charAt(base.length-1) !== '/') ? base + '/' : base;
            const glueCandidates = [];
            try {
                // If base looks absolute (has protocol), use directly.
                const baseUrl = new URL(normalizedBase, self.location.href);
                glueCandidates.push(new URL('wasm_proto.js', baseUrl).href);
                glueCandidates.push(new URL('wasm-proto.js', baseUrl).href);
            } catch (e) {
                // Fallback string concat
                glueCandidates.push((normalizedBase || base).replace(/\/$/, '') + '/wasm_proto.js');
                glueCandidates.push((normalizedBase || base).replace(/\/$/, '') + '/wasm-proto.js');
            }

            // Try each candidate by performing a lightweight HEAD fetch to detect accessibility and CORS.
            let chosenGlue = null;
            let lastFetchErr = null;
            for (const url of glueCandidates) {
                try {
                    const head = await fetch(url, { method: 'HEAD', mode: 'cors' });
                    if (head && head.ok) { chosenGlue = url; break; }
                    lastFetchErr = new Error(`HEAD ${url} -> ${head.status}`);
                } catch (fe) {
                    lastFetchErr = fe;
                }
            }

            if (!chosenGlue) {
                // As a last resort try the first candidate with import() to capture exact error
                try {
                    chosenGlue = glueCandidates[0];
                } catch (e) {}
            }

            // Dynamic import of ESM glue generated by wasm-pack
            let mod;
            try {
                mod = await import(chosenGlue);
                try { self.postMessage({ cmd: 'imported-glue', url: chosenGlue, requestId: msg.requestId }); } catch (e) {}
            } catch (impErr) {
                const errMsg = `dynamic import failed (${chosenGlue}): ${String(impErr)}${lastFetchErr? ' | lastFetchErr: '+String(lastFetchErr):''}`;
                self.postMessage({ cmd: 'error', error: errMsg, requestId: msg.requestId });
                return;
            }

            // The wasm-pack glue usually exports a default init function
            try {
                const wasmUrl = (function() {
                    try { return new URL('wasm_proto_bg.wasm', chosenGlue).href; } catch (e) { return chosenGlue.replace(/\.js$/, '_bg.wasm'); }
                })();
                if (typeof mod.default === 'function') {
                    await mod.default(wasmUrl);
                } else if (typeof mod.init === 'function') {
                    await mod.init(wasmUrl);
                } else if (typeof mod.wasm_bindgen === 'function') {
                    await mod.wasm_bindgen(wasmUrl);
                }
                try { self.postMessage({ cmd: 'wasm-instantiated', url: wasmUrl, requestId: msg.requestId }); } catch (e) {}
            } catch (wbErr) {
                self.postMessage({ cmd: 'error', error: 'wasm init failed: ' + String(wbErr), requestId: msg.requestId });
                return;
            }

            wasmModule = mod;

            // Verify exported compute function is present (try several common names)
            const computeFn = wasmModule.compute_double || wasmModule.computeDouble || (wasmModule.default && wasmModule.default.compute_double) || (globalThis.wasm_bindgen && globalThis.wasm_bindgen.compute_double);
            if (typeof computeFn !== 'function') {
                self.postMessage({ cmd: 'error', error: 'expected export compute_double not found', requestId: msg.requestId });
                return;
            }

            wasmReady = true;
            try { self.postMessage({ cmd: 'ready', requestId: msg.requestId }); } catch (e) {}
        } catch (err) {
            self.postMessage({ cmd: 'error', error: String(err), requestId: msg.requestId });
        }

        return;
    }

    if (msg.cmd === 'compute') {
        if (!wasmReady || !wasmModule) { self.postMessage({ cmd: 'error', error: 'wasm not initialized', requestId: msg.requestId }); return; }
        try {
            const payload = msg.data;
            const arr = (payload instanceof Float64Array) ? payload : new Float64Array(payload);

            // Call the exported wasm function (try common locations)
            let out;
            if (typeof wasmModule.compute_double === 'function') out = wasmModule.compute_double(arr);
            else if (typeof wasmModule.computeDouble === 'function') out = wasmModule.computeDouble(arr);
            else if (wasmModule.default && typeof wasmModule.default.compute_double === 'function') out = wasmModule.default.compute_double(arr);
            else if (globalThis.wasm_bindgen && typeof globalThis.wasm_bindgen.compute_double === 'function') out = globalThis.wasm_bindgen.compute_double(arr);
            else throw new Error('no compute export found');

            // Ensure result is a TypedArray/ArrayBuffer and transfer
            if (out && out.buffer) {
                const buf = out.buffer;
                self.postMessage({ cmd: 'result', result: buf, requestId: msg.requestId }, [buf]);
            } else if (out instanceof ArrayBuffer) {
                self.postMessage({ cmd: 'result', result: out, requestId: msg.requestId }, [out]);
            } else {
                const a = new Float64Array(out);
                self.postMessage({ cmd: 'result', result: a.buffer, requestId: msg.requestId }, [a.buffer]);
            }
        } catch (err) {
            self.postMessage({ cmd: 'error', error: String(err), requestId: msg.requestId });
        }
        return;
    }

    if (msg.cmd === 'compute_vwap') {
        if (!wasmReady || !wasmModule) { self.postMessage({ cmd: 'error', error: 'wasm not initialized', requestId: msg.requestId }); return; }
        try {
            const prices = (msg.prices instanceof Float64Array) ? msg.prices : new Float64Array(msg.prices);
            const vols = (msg.vols instanceof Float64Array) ? msg.vols : new Float64Array(msg.vols);
            // call exported VWAP function
            let out;
            if (typeof wasmModule.compute_vwap === 'function') out = wasmModule.compute_vwap(prices, vols);
            else if (wasmModule.default && typeof wasmModule.default.compute_vwap === 'function') out = wasmModule.default.compute_vwap(prices, vols);
            else if (globalThis.wasm_bindgen && typeof globalThis.wasm_bindgen.compute_vwap === 'function') out = globalThis.wasm_bindgen.compute_vwap(prices, vols);
            else throw new Error('compute_vwap export not found');

            if (out && out.buffer) {
                const buf = out.buffer;
                self.postMessage({ cmd: 'result', result: buf, requestId: msg.requestId }, [buf]);
            } else if (out instanceof ArrayBuffer) {
                self.postMessage({ cmd: 'result', result: out, requestId: msg.requestId }, [out]);
            } else {
                const a = new Float64Array(out);
                self.postMessage({ cmd: 'result', result: a.buffer, requestId: msg.requestId }, [a.buffer]);
            }
        } catch (err) {
            self.postMessage({ cmd: 'error', error: String(err), requestId: msg.requestId });
        }
        return;
    }
});
